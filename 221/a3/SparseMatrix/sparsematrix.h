#pragma once

#include "../TemplateDoublyLinkedList/TemplateDoublyLinkedList.h"
#include "My_vec.h"

#include <iostream>
#include <stdexcept>
#include <string>

typedef My_vec<double> DenseVector;

class SparseMatrix {
public:
  struct Element{
    unsigned int col;
    double val;
    void setVal(double n){
        val = n;
    }
      
    Element(){
        col = 0;
        val = 0.0;
    }
      
    Element(unsigned int c, double v){
        col = c;
        val = v;
    }
  };
  typedef DoublyLinkedList<Element> RowLinkedList;

public:
  class Dimension{};
  SparseMatrix():nrows(0), ncols(0){}                   // constructor of empty matrix
  SparseMatrix(int m, int n);                           // constructor for a m-by-n matrix
  ~SparseMatrix();                                      // destructor

  /*
  No need to implement the following constructors, because they will be
  generated by the compiler correctly if:
      1. The copy/assignment constructors of My_vec is implemented correctly
      2. The copy/assignment constructors of DoublyLinkedList is implemented correctly
  */
  SparseMatrix(const SparseMatrix& input);                    // copy constructor
  SparseMatrix& operator=(const SparseMatrix& input);         // assignment constructor

  int get_rows() const { return nrows; }
  int get_cols() const { return ncols; }
    
  void set_rows(int n) { 
      if(!rows.is_empty()){
        rows.resize();
      }
      nrows = n;
      for(int i = 0; i < nrows; i++){
        rows.insert_at_rank(i, RowLinkedList());
      }
  }
  void set_cols(int n) { ncols = n; }

  RowLinkedList& row(int i) {
    if( i < 0 || i > nrows ) throw std::out_of_range("Row index is out of range!");
    else return rows[i];
  }

  const RowLinkedList& row(int i) const {
    if( i < 0 || i > nrows ) throw std::out_of_range("Row index is out of range!");
    else return rows[i];
  }

  // Implement the following functions
  double get_element_at(int i, int j) const;
  void set_element_at(int i, int j, double n);
  double& operator()(int i, int j);                     // access element (i, j)
  double operator()(int i, int j) const;         // access element (i, j)

  SparseMatrix& operator+(const SparseMatrix& input) const;   // matrix addition A + B
  SparseMatrix& operator-(const SparseMatrix& input) const;   // matrix subtraction A + B
  DenseVector& operator*(const DenseVector& input) const;     // matrix-dense vector multiplication
  SparseMatrix& operator*(const SparseMatrix& input) const;   // matrix-matrix multiplication

  void transpose();                                     // matrix transposition
  void consolidate();                                   // remove all zeros
  void print(const string &title);                                         // display the matrix in human readable form

  friend std::ostream& operator<<(std::ostream &os, const SparseMatrix &A);
  friend std::istream& operator>>(std::ostream &is, SparseMatrix &A);

private:
  int nrows, ncols;                                     // matrix dimension
  My_vec<RowLinkedList> rows;                           // row linked lists
};

inline std::ostream& operator<<(std::ostream &os, const SparseMatrix &A) {
    SparseMatrix B = A;
    B.consolidate();
    for(int i = 0; i < B.nrows; i++){
        DListNode<SparseMatrix::Element> *temp = B.row(i).getFirst();
        while(temp != NULL && temp != B.row(i).getAfterLast()){
            os << i << " " << temp->getElem().col << " " << temp->getElem().val << endl;
            temp = temp->getNext();
        }
        os << endl;
    }
    return os;
}

inline std::istream& operator>>(std::istream &is, SparseMatrix &A) {
    // implement this function
    int rows, cols;
    int rownum, colnum;
    double data;
    is >> rows >> cols;
    A.set_rows(rows);
    A.set_cols(cols);
    while(!is.eof()){
        is >> rownum >> colnum >> data;
        A.set_element_at(rownum,colnum,data);
    }
    return is;
}
